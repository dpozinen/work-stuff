package main.java.work.stuff.parser.entries;

import com.jayway.jsonpath.DocumentContext;
import com.jayway.jsonpath.JsonPath;
import net.minidev.json.JSONObject;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.ThreadLocalRandom;

/**
 * @author dpozinen
 */
@SuppressWarnings("unused")
public final class Entry implements Comparable<Entry> {

	/**
	 * A storage for all the newly created offerKeys and their initial string representations.
	 * If a provided key string in one of {@link #add(String, String)} or {@link #addNormalized(String, String)} or {@link #addTableKey} is present in this map,
	 * the value found by that string is used and no cleaning or creating is performed.
	 * This optimization is important for the Electrolux parsers, where table info is usually extracted as new offerKeys,
	 * but that data is mostly repetitive
	 */
	private static Map<String, OfferKey> customKeyStorage = new HashMap<>();
	private Map<OfferKey, Object> objectStorage;
	private Map<OfferKey, String> stringStorage;
	private Map<OfferKey, Integer> intStorage;
	private Map<OfferKey, BigDecimal> decimalStorage;
	/**
	 * Flag indicating if storage functionality is on or off
	 */
	private boolean store;
	private final IResultEntry entry;
	private final String entryId;
	/**
	 * A flag that indicates whether the entryId provided to the constructor was blank.
	 * Is used to determine if the entry should be added to results or not.
	 * If it is set to true, this means that the entry id was generated by the class itself and was used as a placeholder for the blank id.
	 * Entries like these should not be added to the {@link IResultEntrySet} since they are not valid.
	 * This behaviour provides the option for logging and removes blank checks before creating an entry.
	 */
	private final boolean isIdBlank;

	/**
	 * Always creates an instance of {@link IResultEntry}, but sets the {@link #isIdBlank} to true if the provided id is empty.
	 * Logs the debug link to {@link System#out} if the id was blank.
	 *
	 * @param results the {@link IResultEntrySet} to create an entry from
	 * @param entryId the entry id that will be used for creation
	 * @param debugLink a link that is going to be provided in a log message if the {@param id} is empty
	 * @see #isIdBlank
	 */
	private Entry(IResultEntrySet results, String entryId, UriWrapper debugLink) {
		String id;
		if (entryId == null || entryId.isEmpty()) {
			logEmptyId(debugLink);
			id = String.valueOf(ThreadLocalRandom.current().nextInt());
		} else id = entryId;
		this.isIdBlank = entryId == null || entryId.isEmpty();
		this.entry = results.createResultEntry(id);
		this.entryId = id;
	}

	/**
	 * Creates an instance of {@link Entry}
	 * Static factory method with a link to be debug added to log in case the provided id is empty.
	 *
	 * @param id id to be used as EntryId and ArticleId
	 * @param debugLink link that is going to be provided in a log message if the {@code id} is empty
	 * @return a new instance of entry with ArticleId already set to it
	 */
	public static Entry simpleEntry(IResultEntrySet results, String id, UriWrapper debugLink) {
		return new Entry(results, id, debugLink).articleId(id);
	}

	/**
	 * Same as {@link #simpleEntry(IResultEntrySet, String, UriWrapper)} but without debugLink
	 */
	public static Entry simpleEntry(IResultEntrySet results, String id) {
		return new Entry(results, id, null).articleId(id);
	}

	/**
	 * Same as {@link #createAdded(IResultEntrySet, String, UriWrapper)} but without debugLink
	 */
	public static Entry createAdded(IResultEntrySet results, String id) {
		return new Entry(results, id, null).articleId(id).save(results);
	}

	/**
	 * Same as {@link #simpleEntry(IResultEntrySet, String, UriWrapper)} plus adds the created entry to the results immediately
	 */
	public static Entry createAdded(IResultEntrySet results, String id, UriWrapper uri) {
		return new Entry(results, id, uri).articleId(id).save(results);
	}

	/**
	 * Creates a copy of {@code other}. Important to note that the newly created copy will be empty, if {@link #store} is set to false.
	 * In other words {@link #enableStorage()} should have been called on {@code other} for this copy to be filled, because the content is being taken
	 * from the storage maps and not from {@link #entry}
	 * @param other the entry that the data will be copied from
	 * @return a copy of {@code other}
	 */
	public static Entry copyOf(IResultEntrySet results, String id, Entry other) {
		Entry entry = simpleEntry(results, id);
		if (other.store) {
			entry.store = false;
			other.stringStorage.remove(OfferKey.ArticleId);
			entry.stringStorage = new HashMap<>(other.stringStorage);
			entry.decimalStorage = new HashMap<>(other.decimalStorage);
			entry.intStorage = new HashMap<>(other.intStorage);
			entry.store(OfferKey.ArticleId, id);
			addAllToEntry(entry, other);
		}
		return entry;
	}

	/**
	 * Adds the {@link #entry} to the provided {@link IResultEntrySet}
	 */
	public Entry save(IResultEntrySet results) {
		if (!isIdBlank) results.add(entry);
		return this;
	}

	/**
	 * Enables the storage mechanism provided by the class.
	 * This will save all the added data into {@link Entry} as well as the {@link IResultEntry}.
	 * Storage should only be used for when variant extraction requires a container for common data or for debug purposes.
	 * If you are not planning to call {@link #copyOf(IResultEntrySet, String, Entry)} storage should be off and this method should not be called
	 */
	public Entry enableStorage() {
		if (!store) {
			store = true;
			stringStorage = new HashMap<>(); intStorage = new HashMap<>();
			decimalStorage = new HashMap<>(); objectStorage = new HashMap<>();
			return store(OfferKey.ArticleId, entryId);
		}
		return this;
	}

	/**
	 * Disables the storage. Made public just in case this functionality is ever needed.
	 * Gives an option to clear the stored data.
	 * @param clear flag to indicate if clearing the data is needed
	 * @see #clearStorage()
	 */
	public Entry disableStorage(boolean clear) {
		if (store) {
			store = false;
			return clear ? clearStorage() : this;
		}
		return this;
	}

	/**
	 * Clears the stored values in {@link Entry}. Made public just in case this functionality is ever needed.
	 */
	public Entry clearStorage() {
		if (stringStorage != null) { // if one isn't null -> all aren't
			stringStorage.clear(); intStorage.clear();
			decimalStorage.clear(); objectStorage.clear();
		}
		return this;
	}

	/**
	 * Gives direct access to the underlying {@link IResultEntry} in case it is ever needeed.
	 * @return the inner {@link IResultEntry} at the core of the object
	 */
	public IResultEntry entry() {
		return entry;
	}

	// makers
	public Entry articleId(String id) {
		entry.addEntry(OfferKey.ArticleId, id);
		return store(OfferKey.ArticleId, id);
	}

	public Entry source(String source) {
		entry.addEntry(OfferKey.Source, source);
		return store(OfferKey.Source, source);
	}

	public Entry shopName(String shopName) {
		entry.addEntry(OfferKey.ShopName, shopName);
		return store(OfferKey.ShopName, shopName);
	}

	public Entry imageUrl(String url) {
		entry.addEntry(OfferKey.ImageUrl, url);
		return store(OfferKey.ImageUrl, url);
	}

	public Entry color(String color) {
		entry.addEntry(OfferKey.Color, color);
		return store(OfferKey.Color, color);
	}

	public Entry colorCode(String code) {
		entry.addEntry(OfferKey.ColorCode, code);
		return store(OfferKey.ColorCode, code);
	}

	public Entry deliveryTime(String time) {
		entry.addEntry(OfferKey.DeliveryTime, time);
		return store(OfferKey.DeliveryTime, time);
	}

	public Entry description(String description) { // normalize value
		entry.addEntry(OfferKey.Description, description);
		return store(OfferKey.Description, description);
	}

	public Entry stock(String stock) {
		entry.addEntry(OfferKey.Stock, stock);
		return store(OfferKey.Stock, stock);
	}

	public Entry shopUrl(UriWrapper uri) {
		String url = String.valueOf(uri);
		entry.addEntry(OfferKey.ShopUrl, url);
		return store(OfferKey.ShopUrl, url);
	}

	public Entry collection(String collection) {
		entry.addEntry(OfferKey.Collection, collection);
		return store(OfferKey.Collection, collection);
	}

	public Entry currency(String currency) {
		entry.addEntry(OfferKey.Currency, currency);
		return store(OfferKey.Currency, currency);
	}

	public Entry currency(IQuery query) {
		String currency = ParserUtil.getCurrency(query);
		entry.addEntry(OfferKey.Currency, currency);
		return store(OfferKey.Currency, currency);
	}

	public Entry breadCrumbs(String crumbs) {
		entry.addEntry(OfferKeyConstants.BREADCRUMBS, crumbs);
		return store(OfferKeyConstants.BREADCRUMBS, crumbs);
	}

	public Entry breadCrumbs(Collection<String> crumbs) {
		String joined = StringUtils.join(crumbs, OfferKeyConstants.BREADCRUMB_DELIMITER);
		entry.addEntry(OfferKeyConstants.BREADCRUMBS, joined);
		return store(OfferKeyConstants.BREADCRUMBS, joined);
	}

	public Entry shipping(String shipping) { // todo
		entry.addEntry(OfferKey.Shipping, shipping);
		return store(OfferKey.Shipping, shipping);
	}

	// decimals

	public Entry shipping(BigDecimal shippingNo) {
		String v = shippingNo == null ? null : shippingNo.toString();
		entry.addEntry(OfferKey.Shipping, v);
		return store(OfferKey.Shipping, v);
	}

	public Entry shippingNo(BigDecimal shippingNo) {
		entry.addEntry(OfferKey.ShippinNo, shippingNo);
		return store(OfferKey.ShippinNo, shippingNo);
	}

	public Entry price(BigDecimal price) {
		entry.addEntry(OfferKey.Price, price);
		return store(OfferKey.Price, price);
	}

	public Entry initialPrice(BigDecimal initialPrice) {
		entry.addEntry(OfferKey.InitialPrice, initialPrice);
		return store(OfferKey.InitialPrice, initialPrice);
	}

	public Entry initialPrice(BigDecimal initialPrice, BigDecimal price) {
		if (initialPrice != null && price != null) {
			if (price.compareTo(initialPrice) != 0)
				entry.addEntry(OfferKey.InitialPrice, initialPrice);
		} else
			entry.addEntry(OfferKey.InitialPrice, initialPrice);
		return store(OfferKey.InitialPrice, initialPrice);
	}


	public Entry netPrice(BigDecimal price) {
		entry.addEntry(OfferKey.NetPrice, price);
		return store(OfferKey.NetPrice, price);
	}

	public Entry netInitialPrice(BigDecimal initialPrice) {
		if (initialPrice != null && decimalStorage.get(OfferKey.NetPrice) != null) {
			if (decimalStorage.get(OfferKey.NetPrice).compareTo(initialPrice) != 0)
				entry.addEntry(OfferKey.InitialPrice, initialPrice);
		} else
			entry.addEntry(OfferKey.InitialPrice, initialPrice);
		return store(OfferKey.InitialPrice, initialPrice);
	}

	public Entry rating(BigDecimal rating) {
		if (rating != null && rating.compareTo(BigDecimal.ZERO) != 0)
			entry.addEntry(OfferKey.Rating, rating.setScale(1, RoundingMode.HALF_UP));
		return store(OfferKey.Rating, rating);
	}

	public Entry ratingCount(BigDecimal count) {
		if (count != null && count.intValue() > 0)
			entry.addEntry(OfferKey.RatingCount, count.intValue());
		return store(OfferKey.RatingCount, count);
	}

	// custom makers

	public Entry add(OfferKey key, String value) {
		entry.addEntry(key, value);
		return store(key, value);
	}

	public Entry add(OfferKey key, Object value) {
		entry.addEntry(key, value);
		objectStorage.put(key, value);
		return this;
	}

	/**
	 * Adds the provided key and value, creating an {@link OfferKey} out of the key.
	 * Stores the created key in the {@link #customKeyStorage} for use if it is going to be passed again
	 */
	public Entry add(String key, String value) {
		OfferKey k = customKeyStorage.containsKey(key) ? customKeyStorage.get(key) : createAndSaveKey(key, false);
		entry.addEntry(k, value);
		return store(k, value);
	}

	/**
	 * Same as {@link #add(String, String)} but the value will be normalized
	 */
	public Entry addNormalized(String key, String value) { // todo: normalize text
		OfferKey k = customKeyStorage.containsKey(key) ? customKeyStorage.get(key) : createAndSaveKey(key, false);
		entry.addEntry(k, value);
		return store(k, value);
	}

	/**
	 *
	 * @see #addNormalized(String, String)
	 */
	public Entry addNormalized(OfferKey key, String value) { // todo: normalize text
		entry.addEntry(key, value);
		return store(key, value);
	}

	/**
	 * Creates a key that will be of the format for table data extraction, i.e. TABLE HEAD -> TD_TableHead
	 * @see #add(String, String)
	 */
	public Entry addTableKey(String key, String value) {
		OfferKey k = customKeyStorage.containsKey(key) ? customKeyStorage.get(key) : createAndSaveKey(key, true);
		entry.addEntry(k, value);
		return store(k, value);
	}

	// getters

	/**
	 *
	 * @param key
	 * @param <T>
	 * @return
	 */
	@SuppressWarnings("unchecked")
	public <T> T getOther(OfferKey key) {
		return objectStorage != null ? (T) objectStorage.get(key) : null;
	}

	public Integer getInt(OfferKey key) {
		return intStorage != null ? intStorage.get(key) : null;
	}

	public String getString(OfferKey key) {
		return intStorage != null ? stringStorage.get(key) : "";
	}

	public BigDecimal getDecimal(OfferKey key) {
		return intStorage != null ? decimalStorage.get(key) : null;
	}

	// Overrides

	@Override public int hashCode() {
		return Objects.hashCode(entryId);
	}

	@Override public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;
		Entry entry = (Entry) o;
		return entryId.equals(entry.entryId);
	}

	/**
	 * uses the {@link #entryId} for comparing.
	 * @param o entry for comparing
	 * @throws NullPointerException if the provided object is null
	 */
	@Override public int compareTo(Entry o) {
		return o.entryId.compareTo(entryId);
	}

	/**
	 * Provides a json view for the {@link Entry}. Will return only the entry id if {@link #store} is false
	 * @return a jsonString of the current entry
	 */
	@Override public String toString() {
		if (store) {
			DocumentContext json = JsonPath.parse(new HashMap<>(intStorage))
					.put("$", "decimals", decimalStorage).put("$", "strings", stringStorage);
			if (objectStorage != null && !objectStorage.isEmpty())
				json.put("$", "other", objectStorage).jsonString();
			return json.jsonString();
		} else {
			JSONObject o = new JSONObject();
			o.put("EntryId", entryId);
			return o.toJSONString();
		}
	}

	// privates

	private Entry store(OfferKey key, String id) {
		if (store) stringStorage.put(key, id);
		return this;
	}

	private Entry store(OfferKey key, BigDecimal id) {
		if (store) decimalStorage.put(key, id);
		return this;
	}

	private Entry store(OfferKey key, Integer id) {
		if (store) intStorage.put(key, id);
		return this;
	}

	private OfferKey createAndSaveKey(String key, boolean isTableKey) {
		String finalKey = isTableKey ? "TD_" + key : key;
		OfferKey offerKey = ParserUtil.createCleanOfferKeyName(finalKey);
		customKeyStorage.put(key, offerKey);
		return offerKey;
	}

	private static void addAllToEntry(Entry target, Entry other) {
		for (Map.Entry<OfferKey, String> e : other.stringStorage.entrySet()) target.entry.addEntry(e.getKey(), e.getValue());
		for (Map.Entry<OfferKey, Integer> e : other.intStorage.entrySet()) target.entry.addEntry(e.getKey(), e.getValue());
		for (Map.Entry<OfferKey, BigDecimal> e : other.decimalStorage.entrySet()) target.entry.addEntry(e.getKey(), e.getValue());
		for (Map.Entry<OfferKey, Object> e : other.objectStorage.entrySet()) target.entry.addEntry(e.getKey(), e.getValue());
	}

	/**
	 * Prints instances when the provided entry id for construction was empty
	 * @param debugLink a link at which the entry was created
	 */
	private static void logEmptyId(UriWrapper debugLink) {
		if (debugLink == null)
			System.out.println("LOG: entry was not created due to empty id. No further info available");
		else
			System.out.printf("LOG: entry was not created due to empty id. Found on page: %s", debugLink);
	}

}
